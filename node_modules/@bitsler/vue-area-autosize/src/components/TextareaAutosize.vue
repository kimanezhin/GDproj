<template>
  <textarea
    v-model="localValue"
    :style="computedStyles"
    :rows="minRows"
    :autocomplete="autocomplete"
    :placeholder="placeholder"
    :maxlength="maxLength"
    spellcheck="true"
    @focus="resize"
    @input="onInput"
  />
</template>
<script>
export default {
  name: 'TextareaAutosize',
  props: {
    value: {
      type: [String, Number],
      default: ''
    },
    maxLength: {
      type: Number,
      default: 250
    },
    autosize: {
      type: Boolean,
      default: true
    },
    minHeight: {
      type: [Number],
      'default': null
    },
    maxHeight: {
      type: [Number],
      'default': null
    },
    important: {
      type: [Boolean, Array],
      default: false
    },
    minRows: {
      type: Number,
      default: 1
    },
    autocomplete: {
      type: String,
      default: 'off'
    },
    placeholder: {
      type: String,
      default: ''
    },
    debug: {
      type: Boolean,
      default: false
    }
  },
  data () {
    return {
      // works when content height becomes more then value of the maxHeight property
      maxHeightScroll: false
    };
  },
  computed: {
    localValue: {
      get: function () {
        this.onDebug('localValue_get', this.value);
        return this.value;
      },
      set: function (aModifiedValue) {
        this.onDebug('localValue_set', aModifiedValue);
        this.$emit('input', aModifiedValue.substring(0, this.maxLength));
      }
    },
    computedStyles () {
      let objStyles = {};
      if (this.autosize) {
        objStyles.resize = !this.isResizeImportant ? 'none' : 'none !important';
        if (!this.maxHeightScroll) {
          objStyles.overflow = !this.isOverflowImportant ? 'hidden' : 'hidden !important';
        }
      }
      return objStyles;
    },
    isResizeImportant () {
      const imp = this.important;
      return imp === true || (Array.isArray(imp) && imp.includes('resize'));
    },
    isOverflowImportant () {
      const imp = this.important;
      return imp === true || (Array.isArray(imp) && imp.includes('overflow'));
    },
    isHeightImportant () {
      const imp = this.important;
      return imp === true || (Array.isArray(imp) && imp.includes('height'));
    }
  },
  watch: {
    localValue (newVal, oldVal) {
      this.$nextTick(this.resize);
      this.onDebug('watch_localValue', newVal, oldVal);
      if (newVal !== oldVal) {
        this.$emit('input', newVal);
      }
    }
  },
  created () {
    this.updateVal(); // fill val with initial value passed via the same name prop
  },
  mounted () {
    this.resize(); // perform initial height adjustment
  },
  methods: {
    onDebug(...args){
      if(this.debug) {
        console.log('[vue-area-autosize]:', ...args);
      }
    },
    onInput(evt) {
      this.onDebug('onInput', evt.target.value);
      this.localValue = evt.target.value;
    },
    /*
     * Update local val with prop value
     */
    updateVal () {
      this.onDebug('updateVal', this.value);
      this.localValue = this.value;
    },
    /*
     * Auto resize textarea by height
     */
    resize: function () {
      const important = this.isHeightImportant ? 'important' : '';
      this.$el.style.setProperty('height', 'auto', important);
      let contentHeight = this.$el.scrollHeight + 1;
      if (this.minHeight) {
        contentHeight = contentHeight < this.minHeight ? this.minHeight : contentHeight;
      }
      if (this.maxHeight) {
        if (contentHeight > this.maxHeight) {
          contentHeight = this.maxHeight;
          this.maxHeightScroll = true;
        } else {
          this.maxHeightScroll = false;
        }
      }
      const heightVal = contentHeight + 'px';
      this.$el.style.setProperty('height', heightVal, important);
      return this;
    }
  }
};
</script>